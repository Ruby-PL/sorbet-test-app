# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dalli` gem.
# Please instead update this file by running `bin/tapioca gem dalli`.

# source://dalli-2.7.11/lib/dalli/compressor.rb:5
module Dalli
  class << self
    # source://dalli-2.7.11/lib/dalli.rb:34
    def default_logger; end

    # source://dalli-2.7.11/lib/dalli.rb:25
    def logger; end

    # source://dalli-2.7.11/lib/dalli.rb:41
    def logger=(logger); end

    # source://dalli-2.7.11/lib/dalli.rb:29
    def rails_logger; end
  end
end

# source://dalli-2.7.11/lib/dalli/client.rb:7
class Dalli::Client
  # Dalli::Client is the main class which developers will use to interact with
  # the memcached server.  Usage:
  #
  #   Dalli::Client.new(['localhost:11211:10', 'cache-2.example.com:11211:5', '192.168.0.1:22122:5', '/var/run/memcached/socket'],
  #                   :threadsafe => true, :failover => true, :expires_in => 300)
  #
  # servers is an Array of "host:port:weight" where weight allows you to distribute cache unevenly.
  # Both weight and port are optional.  If you pass in nil, Dalli will use the <tt>MEMCACHE_SERVERS</tt>
  # environment variable or default to 'localhost:11211' if it is not present.  Dalli also supports
  # the ability to connect to Memcached on localhost through a UNIX socket.  To use this functionality,
  # use a full pathname (beginning with a slash character '/') in place of the "host:port" pair in
  # the server configuration.
  #
  # Options:
  # - :namespace - prepend each key with this value to provide simple namespacing.
  # - :failover - if a server is down, look for and store values on another server in the ring.  Default: true.
  # - :threadsafe - ensure that only one thread is actively using a socket at a time. Default: true.
  # - :expires_in - default TTL in seconds if you do not pass TTL as a parameter to an individual operation, defaults to 0 or forever
  # - :compress - defaults to false, if true Dalli will compress values larger than 1024 bytes before sending them to memcached.
  # - :serializer - defaults to Marshal
  # - :compressor - defaults to zlib
  # - :cache_nils - defaults to false, if true Dalli will not treat cached nil values as 'not found' for #fetch operations.
  # - :digest_class - defaults to Digest::MD5, allows you to pass in an object that responds to the hexdigest method, useful for injecting a FIPS compliant hash object.
  #
  # @return [Client] a new instance of Client
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:34
  def initialize(servers = T.unsafe(nil), options = T.unsafe(nil)); end

  # Conditionally add a key/value pair, if the key does not already exist
  # on the server.  Returns truthy if the operation succeeded.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:137
  def add(key, value, ttl = T.unsafe(nil), options = T.unsafe(nil)); end

  # Make sure memcache servers are alive, or raise an Dalli::RingError
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:240
  def alive!; end

  # Append value to the value already stored on the server for 'key'.
  # Appending only works for values stored with :raw => true.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:155
  def append(key, value); end

  # compare and swap values using optimistic locking.
  # Fetch the existing value for key.
  # If it exists, yield the value to the block.
  # Add the block's return value as the new value for the key.
  # Add will fail if someone else changed the value.
  #
  # Returns:
  # - nil if the key did not exist.
  # - false if the value was changed by someone else.
  # - true if the value was successfully updated.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:115
  def cas(key, ttl = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # like #cas, but will yield to the block whether or not the value
  # already exists.
  #
  # Returns:
  # - false if the value was changed by someone else.
  # - true if the value was successfully updated.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:126
  def cas!(key, ttl = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Close our connection to each server.
  # If you perform another operation after this, the connections will be re-established.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:257
  def close; end

  # Decr subtracts the given amount from the counter on the memcached server.
  # Amt must be a positive integer value.
  #
  # memcached counters are unsigned and cannot hold negative values.  Calling
  # decr on a counter which is 0 will just return 0.
  #
  # If default is nil, the counter must already exist or the operation
  # will fail and will return nil.  Otherwise this method will return
  # the new value for the counter.
  #
  # Note that the ttl will only apply if the counter does not already
  # exist.  To decrease an existing counter and update its TTL, use
  # #cas.
  #
  # @raise [ArgumentError]
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:203
  def decr(key, amt = T.unsafe(nil), ttl = T.unsafe(nil), default = T.unsafe(nil)); end

  # source://dalli-2.7.11/lib/dalli/client.rb:148
  def delete(key); end

  # Fetch the value associated with the key.
  # If a value is found, then it is returned.
  #
  # If a value is not found and no block is given, then nil is returned.
  #
  # If a value is not found (or if the found value is nil and :cache_nils is false)
  # and a block is given, the block will be invoked and its return value
  # written to the cache and returned.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:91
  def fetch(key, ttl = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://dalli-2.7.11/lib/dalli/client.rb:166
  def flush(delay = T.unsafe(nil)); end

  # source://dalli-2.7.11/lib/dalli/client.rb:166
  def flush_all(delay = T.unsafe(nil)); end

  # Get the value associated with the key.
  # If a value is not found, then +nil+ is returned.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:59
  def get(key, options = T.unsafe(nil)); end

  # Fetch multiple keys efficiently.
  # If a block is given, yields key/value pairs one at a time.
  # Otherwise returns a hash of { 'key' => 'value', 'key2' => 'value1' }
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:67
  def get_multi(*keys); end

  # Incr adds the given amount to the counter on the memcached server.
  # Amt must be a positive integer value.
  #
  # If default is nil, the counter must already exist or the operation
  # will fail and will return nil.  Otherwise this method will return
  # the new value for the counter.
  #
  # Note that the ttl will only apply if the counter does not already
  # exist.  To increase an existing counter and update its TTL, use
  # #cas.
  #
  # @raise [ArgumentError]
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:184
  def incr(key, amt = T.unsafe(nil), ttl = T.unsafe(nil), default = T.unsafe(nil)); end

  # Turn on quiet aka noreply support.
  # All relevant operations within this block will be effectively
  # pipelined as Dalli will use 'quiet' operations where possible.
  # Currently supports the set, add, replace and delete operations.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:49
  def multi; end

  # Prepend value to the value already stored on the server for 'key'.
  # Prepending only works for values stored with :raw => true.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:162
  def prepend(key, value); end

  # Conditionally add a key/value pair, only if the key already exists
  # on the server.  Returns truthy if the operation succeeded.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:144
  def replace(key, value, ttl = T.unsafe(nil), options = T.unsafe(nil)); end

  # Close our connection to each server.
  # If you perform another operation after this, the connections will be re-established.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:257
  def reset; end

  # Reset stats for each server.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:232
  def reset_stats; end

  # source://dalli-2.7.11/lib/dalli/client.rb:130
  def set(key, value, ttl = T.unsafe(nil), options = T.unsafe(nil)); end

  # Collect the stats for each server.
  # You can optionally pass a type including :items, :slabs or :settings to get specific stats
  # Returns a hash like { 'hostname:port' => { 'stat1' => 'value1', ... }, 'hostname2:port' => { ... } }
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:221
  def stats(type = T.unsafe(nil)); end

  # Touch updates expiration time for a given key.
  #
  # Returns true if key exists, otherwise nil.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:212
  def touch(key, ttl = T.unsafe(nil)); end

  # Version of the memcache servers.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:246
  def version; end

  # Stub method so a bare Dalli client can pretend to be a connection pool.
  #
  # @yield [_self]
  # @yieldparam _self [Dalli::Client] the object that the method was called on
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:266
  def with; end

  private

  # source://dalli-2.7.11/lib/dalli/client.rb:272
  def cas_core(key, always_set, ttl = T.unsafe(nil), options = T.unsafe(nil)); end

  # Yields, one at a time, keys and their values+attributes.
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:422
  def get_multi_yielder(keys); end

  # source://dalli-2.7.11/lib/dalli/client.rb:286
  def groups_for_keys(*keys); end

  # source://dalli-2.7.11/lib/dalli/client.rb:391
  def key_with_namespace(key); end

  # source://dalli-2.7.11/lib/dalli/client.rb:395
  def key_without_namespace(key); end

  # source://dalli-2.7.11/lib/dalli/client.rb:304
  def make_multi_get_requests(groups); end

  # source://dalli-2.7.11/lib/dalli/client.rb:298
  def mapped_keys(keys); end

  # source://dalli-2.7.11/lib/dalli/client.rb:399
  def namespace; end

  # source://dalli-2.7.11/lib/dalli/client.rb:404
  def normalize_options(opts); end

  # Normalizes the argument into an array of servers.
  # If the argument is a string, or an array containing strings, it's expected that the URIs are comma separated e.g.
  # "memcache1.example.com:11211,memcache2.example.com:11211,memcache3.example.com:11211"
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:337
  def normalize_servers(servers); end

  # Chokepoint method for instrumentation
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:363
  def perform(*all_args); end

  # source://dalli-2.7.11/lib/dalli/client.rb:319
  def perform_multi_response_start(servers); end

  # source://dalli-2.7.11/lib/dalli/client.rb:347
  def ring; end

  # source://dalli-2.7.11/lib/dalli/client.rb:280
  def ttl_or_default(ttl); end

  # @raise [ArgumentError]
  #
  # source://dalli-2.7.11/lib/dalli/client.rb:380
  def validate_key(key); end
end

# source://dalli-2.7.11/lib/dalli/client.rb:81
Dalli::Client::CACHE_NILS = T.let(T.unsafe(nil), Hash)

# source://dalli-2.7.11/lib/dalli/compressor.rb:6
class Dalli::Compressor
  class << self
    # source://dalli-2.7.11/lib/dalli/compressor.rb:7
    def compress(data); end

    # source://dalli-2.7.11/lib/dalli/compressor.rb:11
    def decompress(data); end
  end
end

# generic error
#
# source://dalli-2.7.11/lib/dalli.rb:13
class Dalli::DalliError < ::RuntimeError; end

# source://dalli-2.7.11/lib/dalli/compressor.rb:16
class Dalli::GzipCompressor
  class << self
    # source://dalli-2.7.11/lib/dalli/compressor.rb:17
    def compress(data); end

    # source://dalli-2.7.11/lib/dalli/compressor.rb:25
    def decompress(data); end
  end
end

# application error in marshalling serialization
#
# source://dalli-2.7.11/lib/dalli.rb:19
class Dalli::MarshalError < ::Dalli::DalliError; end

# socket/server communication error
#
# source://dalli-2.7.11/lib/dalli.rb:15
class Dalli::NetworkError < ::Dalli::DalliError; end

# source://dalli-2.7.11/lib/dalli/railtie.rb:3
class Dalli::Railtie < ::Rails::Railtie; end

# source://dalli-2.7.11/lib/dalli/ring.rb:6
class Dalli::Ring
  # @return [Ring] a new instance of Ring
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:11
  def initialize(servers, options); end

  # Returns the value of attribute continuum.
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:9
  def continuum; end

  # Sets the attribute continuum
  #
  # @param value the value to set the attribute continuum to.
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:9
  def continuum=(_arg0); end

  # source://dalli-2.7.11/lib/dalli/ring.rb:49
  def lock; end

  # @raise [Dalli::RingError]
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:31
  def server_for_key(key); end

  # Returns the value of attribute servers.
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:9
  def servers; end

  # Sets the attribute servers
  #
  # @param value the value to set the attribute servers to.
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:9
  def servers=(_arg0); end

  private

  # source://dalli-2.7.11/lib/dalli/ring.rb:111
  def binary_search(ary, value); end

  # source://dalli-2.7.11/lib/dalli/ring.rb:70
  def entry_count_for(server, total_servers, total_weight); end

  # source://dalli-2.7.11/lib/dalli/ring.rb:66
  def hash_for(key); end

  # source://dalli-2.7.11/lib/dalli/ring.rb:60
  def threadsafe!; end
end

# source://dalli-2.7.11/lib/dalli/ring.rb:131
class Dalli::Ring::Entry
  # @return [Entry] a new instance of Entry
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:135
  def initialize(val, srv); end

  # Returns the value of attribute server.
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:133
  def server; end

  # Returns the value of attribute value.
  #
  # source://dalli-2.7.11/lib/dalli/ring.rb:132
  def value; end
end

# this is the default in libmemcached
#
# source://dalli-2.7.11/lib/dalli/ring.rb:7
Dalli::Ring::POINTS_PER_SERVER = T.let(T.unsafe(nil), Integer)

# no server available/alive error
#
# source://dalli-2.7.11/lib/dalli.rb:17
class Dalli::RingError < ::Dalli::DalliError; end

# source://dalli-2.7.11/lib/dalli/server.rb:6
class Dalli::Server
  # @return [Server] a new instance of Server
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:44
  def initialize(attribs, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:85
  def alive?; end

  # source://dalli-2.7.11/lib/dalli/server.rb:100
  def close; end

  # source://dalli-2.7.11/lib/dalli/server.rb:118
  def compressor; end

  # Returns the value of attribute hostname.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:7
  def hostname; end

  # Sets the attribute hostname
  #
  # @param value the value to set the attribute hostname to.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:7
  def hostname=(_arg0); end

  # source://dalli-2.7.11/lib/dalli/server.rb:108
  def lock!; end

  # Abort an earlier #multi_response_start. Used to signal an external
  # timeout. The underlying socket is disconnected, and the exception is
  # swallowed.
  #
  # Returns nothing.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:194
  def multi_response_abort; end

  # Did the last call to #multi_response_start complete successfully?
  #
  # @return [Boolean]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:136
  def multi_response_completed?; end

  # Attempt to receive and parse as many key/value pairs as possible
  # from this server. After #multi_response_start, this should be invoked
  # repeatedly whenever this server's socket is readable until
  # #multi_response_completed?.
  #
  # Returns a Hash of kv pairs received.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:146
  def multi_response_nonblock; end

  # Start reading key/value pairs from this connection. This is usually called
  # after a series of GETKQ commands. A NOOP is sent, and the server begins
  # flushing responses for kv pairs that were found.
  #
  # Returns nothing.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:127
  def multi_response_start; end

  # source://dalli-2.7.11/lib/dalli/server.rb:57
  def name; end

  # Returns the value of attribute options.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:10
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:10
  def options=(_arg0); end

  # Returns the value of attribute port.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:8
  def port; end

  # Sets the attribute port
  #
  # @param value the value to set the attribute port to.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:8
  def port=(_arg0); end

  # Chokepoint method for instrumentation
  #
  # @raise [Dalli::NetworkError]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:66
  def request(op, *args); end

  # source://dalli-2.7.11/lib/dalli/server.rb:114
  def serializer; end

  # Returns the value of attribute sock.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:11
  def sock; end

  # possible values: :unix, :tcp
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:12
  def socket_type; end

  # source://dalli-2.7.11/lib/dalli/server.rb:111
  def unlock!; end

  # Returns the value of attribute weight.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:9
  def weight; end

  # Sets the attribute weight
  #
  # @param value the value to set the attribute weight to.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:9
  def weight=(_arg0); end

  private

  # source://dalli-2.7.11/lib/dalli/server.rb:295
  def add(key, value, ttl, options); end

  # source://dalli-2.7.11/lib/dalli/server.rb:369
  def append(key, value); end

  # source://dalli-2.7.11/lib/dalli/server.rb:387
  def cas(key); end

  # source://dalli-2.7.11/lib/dalli/server.rb:522
  def cas_response; end

  # source://dalli-2.7.11/lib/dalli/server.rb:585
  def connect; end

  # source://dalli-2.7.11/lib/dalli/server.rb:457
  def data_cas_response; end

  # source://dalli-2.7.11/lib/dalli/server.rb:340
  def decr(key, count, ttl, default); end

  # source://dalli-2.7.11/lib/dalli/server.rb:329
  def decr_incr(opcode, key, count, ttl, default); end

  # source://dalli-2.7.11/lib/dalli/server.rb:317
  def delete(key, cas); end

  # source://dalli-2.7.11/lib/dalli/server.rb:440
  def deserialize(value, flags); end

  # @raise [Dalli::NetworkError]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:234
  def down!; end

  # source://dalli-2.7.11/lib/dalli/server.rb:222
  def failure!(exception); end

  # source://dalli-2.7.11/lib/dalli/server.rb:323
  def flush(ttl); end

  # source://dalli-2.7.11/lib/dalli/server.rb:504
  def generic_response(unpack = T.unsafe(nil), cache_nils = T.unsafe(nil)); end

  # source://dalli-2.7.11/lib/dalli/server.rb:269
  def get(key, options = T.unsafe(nil)); end

  # source://dalli-2.7.11/lib/dalli/server.rb:476
  def guard_max_value(key, value); end

  # source://dalli-2.7.11/lib/dalli/server.rb:344
  def incr(key, count, ttl, default); end

  # source://dalli-2.7.11/lib/dalli/server.rb:536
  def keyvalue_response; end

  # @return [Boolean]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:265
  def multi?; end

  # source://dalli-2.7.11/lib/dalli/server.rb:547
  def multi_response; end

  # SASL authentication support for NorthScale
  #
  # @return [Boolean]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:689
  def need_auth?; end

  # Noop is a keepalive operation but also used to demarcate the end of a set of pipelined commands.
  # We need to read all the responses at once.
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:364
  def noop; end

  # @raise [Dalli::DalliError]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:732
  def parse_hostname(str); end

  # source://dalli-2.7.11/lib/dalli/server.rb:697
  def password; end

  # source://dalli-2.7.11/lib/dalli/server.rb:373
  def prepend(key, value); end

  # source://dalli-2.7.11/lib/dalli/server.rb:570
  def read(count); end

  # source://dalli-2.7.11/lib/dalli/server.rb:581
  def read_header; end

  # @raise [Dalli::NetworkError]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:216
  def reconnect!(message); end

  # source://dalli-2.7.11/lib/dalli/server.rb:306
  def replace(key, value, ttl, cas, options); end

  # source://dalli-2.7.11/lib/dalli/server.rb:383
  def reset_stats; end

  # 30 days
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:491
  def sanitize_ttl(ttl); end

  # @raise [Dalli::NetworkError]
  #
  # source://dalli-2.7.11/lib/dalli/server.rb:701
  def sasl_authentication; end

  # source://dalli-2.7.11/lib/dalli/server.rb:275
  def send_multiget(keys); end

  # source://dalli-2.7.11/lib/dalli/server.rb:408
  def serialize(key, value, options = T.unsafe(nil)); end

  # source://dalli-2.7.11/lib/dalli/server.rb:284
  def set(key, value, ttl, cas, options); end

  # source://dalli-2.7.11/lib/dalli/server.rb:606
  def split(n); end

  # source://dalli-2.7.11/lib/dalli/server.rb:377
  def stats(info = T.unsafe(nil)); end

  # source://dalli-2.7.11/lib/dalli/server.rb:397
  def touch(key, ttl); end

  # source://dalli-2.7.11/lib/dalli/server.rb:252
  def up!; end

  # source://dalli-2.7.11/lib/dalli/server.rb:693
  def username; end

  # source://dalli-2.7.11/lib/dalli/server.rb:207
  def verify_state; end

  # source://dalli-2.7.11/lib/dalli/server.rb:393
  def version; end

  # source://dalli-2.7.11/lib/dalli/server.rb:559
  def write(bytes); end

  # source://dalli-2.7.11/lib/dalli/server.rb:348
  def write_append_prepend(opcode, key, value); end

  # source://dalli-2.7.11/lib/dalli/server.rb:352
  def write_generic(bytes); end

  # source://dalli-2.7.11/lib/dalli/server.rb:357
  def write_noop; end
end

# source://dalli-2.7.11/lib/dalli/server.rb:472
Dalli::Server::CAS_HEADER = T.let(T.unsafe(nil), String)

# source://dalli-2.7.11/lib/dalli/server.rb:16
Dalli::Server::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://dalli-2.7.11/lib/dalli/server.rb:14
Dalli::Server::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# source://dalli-2.7.11/lib/dalli/server.rb:15
Dalli::Server::DEFAULT_WEIGHT = T.let(T.unsafe(nil), Integer)

# source://dalli-2.7.11/lib/dalli/server.rb:406
Dalli::Server::FLAG_COMPRESSED = T.let(T.unsafe(nil), Integer)

# http://www.hjp.at/zettel/m/memcached_flags.rxml
# Looks like most clients use bit 0 to indicate native language serialization
# and bit 1 to indicate gzip compression.
#
# source://dalli-2.7.11/lib/dalli/server.rb:405
Dalli::Server::FLAG_SERIALIZED = T.let(T.unsafe(nil), Integer)

# source://dalli-2.7.11/lib/dalli/server.rb:682
Dalli::Server::FORMAT = T.let(T.unsafe(nil), Hash)

# source://dalli-2.7.11/lib/dalli/server.rb:662
Dalli::Server::HEADER = T.let(T.unsafe(nil), String)

# source://dalli-2.7.11/lib/dalli/socket.rb:95
module Dalli::Server::KSocket
  include ::Dalli::Server::KSocket::InstanceMethods

  class << self
    # source://dalli-2.7.11/lib/dalli/socket.rb:128
    def included(receiver); end
  end
end

# source://dalli-2.7.11/lib/dalli/socket.rb:96
module Dalli::Server::KSocket::InstanceMethods
  # source://dalli-2.7.11/lib/dalli/socket.rb:115
  def read_available; end

  # source://dalli-2.7.11/lib/dalli/socket.rb:97
  def readfull(count); end
end

# source://dalli-2.7.11/lib/dalli/socket.rb:134
class Dalli::Server::KSocket::TCP < ::TCPSocket
  include ::Dalli::Server::KSocket
  include ::Dalli::Server::KSocket::InstanceMethods
  extend ::Dalli::Server::TCPSocketOptions

  # source://dalli-2.7.11/lib/dalli/socket.rb:129
  def options; end

  # source://dalli-2.7.11/lib/dalli/socket.rb:129
  def options=(_arg0); end

  # source://dalli-2.7.11/lib/dalli/socket.rb:129
  def server; end

  # source://dalli-2.7.11/lib/dalli/socket.rb:129
  def server=(_arg0); end

  class << self
    # source://dalli-2.7.11/lib/dalli/socket.rb:138
    def open(host, port, server, options = T.unsafe(nil)); end
  end
end

# source://dalli-2.7.11/lib/dalli/socket.rb:156
class Dalli::Server::KSocket::UNIX < ::UNIXSocket
  include ::Dalli::Server::KSocket
  include ::Dalli::Server::KSocket::InstanceMethods

  # source://dalli-2.7.11/lib/dalli/socket.rb:129
  def options; end

  # source://dalli-2.7.11/lib/dalli/socket.rb:129
  def options=(_arg0); end

  # source://dalli-2.7.11/lib/dalli/socket.rb:129
  def server; end

  # source://dalli-2.7.11/lib/dalli/socket.rb:129
  def server=(_arg0); end

  class << self
    # source://dalli-2.7.11/lib/dalli/socket.rb:159
    def open(path, server, options = T.unsafe(nil)); end
  end
end

# source://dalli-2.7.11/lib/dalli/server.rb:474
Dalli::Server::KV_HEADER = T.let(T.unsafe(nil), String)

# https://github.com/memcached/memcached/blob/master/doc/protocol.txt#L79
# > An expiration time, in seconds. Can be up to 30 days. After 30 days, is treated as a unix timestamp of an exact date.
#
# source://dalli-2.7.11/lib/dalli/server.rb:490
Dalli::Server::MAX_ACCEPTABLE_EXPIRATION_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://dalli-2.7.11/lib/dalli/server.rb:473
Dalli::Server::NORMAL_HEADER = T.let(T.unsafe(nil), String)

# source://dalli-2.7.11/lib/dalli/server.rb:502
Dalli::Server::NOT_FOUND = T.let(T.unsafe(nil), Dalli::Server::NilObject)

# Implements the NullObject pattern to store an application-defined value for 'Key not found' responses.
#
# source://dalli-2.7.11/lib/dalli/server.rb:501
class Dalli::Server::NilObject; end

# source://dalli-2.7.11/lib/dalli/server.rb:635
Dalli::Server::OPCODES = T.let(T.unsafe(nil), Hash)

# source://dalli-2.7.11/lib/dalli/server.rb:663
Dalli::Server::OP_FORMAT = T.let(T.unsafe(nil), Hash)

# source://dalli-2.7.11/lib/dalli/server.rb:610
Dalli::Server::REQUEST = T.let(T.unsafe(nil), Integer)

# source://dalli-2.7.11/lib/dalli/server.rb:611
Dalli::Server::RESPONSE = T.let(T.unsafe(nil), Integer)

# Response codes taken from:
# https://github.com/memcached/memcached/wiki/BinaryProtocolRevamped#response-status
#
# source://dalli-2.7.11/lib/dalli/server.rb:615
Dalli::Server::RESPONSE_CODES = T.let(T.unsafe(nil), Hash)

# source://dalli-2.7.11/lib/dalli/socket.rb:4
module Dalli::Server::TCPSocketOptions
  # source://dalli-2.7.11/lib/dalli/socket.rb:5
  def setsockopts(sock, options); end
end

# Make Dalli threadsafe by using a lock around all
# public server methods.
#
# Dalli::Server.extend(Dalli::Threadsafe)
#
# source://dalli-2.7.11/lib/dalli/options.rb:12
module Dalli::Threadsafe
  # @return [Boolean]
  #
  # source://dalli-2.7.11/lib/dalli/options.rb:23
  def alive?; end

  # source://dalli-2.7.11/lib/dalli/options.rb:29
  def close; end

  # source://dalli-2.7.11/lib/dalli/options.rb:61
  def init_threadsafe; end

  # source://dalli-2.7.11/lib/dalli/options.rb:53
  def lock!; end

  # source://dalli-2.7.11/lib/dalli/options.rb:47
  def multi_response_abort; end

  # source://dalli-2.7.11/lib/dalli/options.rb:41
  def multi_response_nonblock; end

  # source://dalli-2.7.11/lib/dalli/options.rb:35
  def multi_response_start; end

  # source://dalli-2.7.11/lib/dalli/options.rb:17
  def request(op, *args); end

  # source://dalli-2.7.11/lib/dalli/options.rb:57
  def unlock!; end

  class << self
    # @private
    #
    # source://dalli-2.7.11/lib/dalli/options.rb:13
    def extended(obj); end
  end
end

# application error in marshalling deserialization or decompression
#
# source://dalli-2.7.11/lib/dalli.rb:21
class Dalli::UnmarshalError < ::Dalli::DalliError; end

# source://dalli-2.7.11/lib/dalli/version.rb:3
Dalli::VERSION = T.let(T.unsafe(nil), String)

# payload too big for memcached
#
# source://dalli-2.7.11/lib/dalli.rb:23
class Dalli::ValueOverMaxSize < ::Dalli::DalliError; end

# source://dalli-2.7.11/lib/rack/session/dalli.rb:5
module Rack
  class << self
    # source://rack-2.2.4/lib/rack/version.rb:26
    def release; end

    # source://rack-2.2.4/lib/rack/version.rb:19
    def version; end
  end
end

# source://rack-2.2.4/lib/rack.rb:29
Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:31
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:32
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:43
Rack::DELETE = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:36
Rack::ETAG = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:30
Rack::EXPIRES = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack/file.rb:6
Rack::File = Rack::Files

# source://rack-2.2.4/lib/rack.rb:39
Rack::GET = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:44
Rack::HEAD = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:20
Rack::HTTPS = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:35
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:17
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:18
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:19
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:46
Rack::LINK = T.let(T.unsafe(nil), String)

# source://rack-test-2.0.2/lib/rack/test.rb:413
Rack::MockSession = Rack::Test::Session

# source://rack-2.2.4/lib/rack.rb:45
Rack::OPTIONS = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:42
Rack::PATCH = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:21
Rack::PATH_INFO = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:40
Rack::POST = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:41
Rack::PUT = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:25
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:53
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:63
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:65
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:55
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:64
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:54
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:76
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:67
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:68
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:60
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:59
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:66
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:72
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:73
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:70
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:69
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:71
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:74
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:75
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:61
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:56
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:57
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:77
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:58
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:52
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:62
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:51
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack/version.rb:23
Rack::RELEASE = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:22
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:23
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:24
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:27
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:28
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:26
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:33
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)

# source://dalli-2.7.11/lib/rack/session/dalli.rb:6
module Rack::Session; end

# source://dalli-2.7.11/lib/rack/session/dalli.rb:7
class Rack::Session::Dalli < ::Rack::Session::Abstract::Persisted
  # Brings in a new Rack::Session::Dalli middleware with the given
  # `:memcache_server`. The server is either a hostname, or a
  # host-with-port string in the form of "host_name:port", or an array of
  # such strings. For example:
  #
  #   use Rack::Session::Dalli,
  #     :memcache_server => "mc.example.com:1234"
  #
  # If no `:memcache_server` option is specified, Rack::Session::Dalli will
  # connect to localhost, port 11211 (the default memcached port). If
  # `:memcache_server` is set to nil, Dalli::Client will look for
  # ENV['MEMCACHE_SERVERS'] and use that value if it is available, or fall
  # back to the same default behavior described above.
  #
  # Rack::Session::Dalli is intended to be a drop-in replacement for
  # Rack::Session::Memcache. It accepts additional options that control the
  # behavior of Rack::Session, Dalli::Client, and an optional
  # ConnectionPool. First and foremost, if you wish to instantiate your own
  # Dalli::Client (or ConnectionPool) and use that instead of letting
  # Rack::Session::Dalli instantiate it on your behalf, simply pass it in
  # as the `:cache` option. Please note that you will be responsible for
  # setting the namespace and any other options on Dalli::Client.
  #
  # Secondly, if you're not using the `:cache` option, Rack::Session::Dalli
  # accepts the same options as Dalli::Client, so it's worth reviewing its
  # documentation. Perhaps most importantly, if you don't specify a
  # `:namespace` option, Rack::Session::Dalli will default to using
  # "rack:session".
  #
  # Whether you are using the `:cache` option or not, it is not recommend
  # to set `:expires_in`. Instead, use `:expire_after`, which will control
  # both the expiration of the client cookie as well as the expiration of
  # the corresponding entry in memcached.
  #
  # Rack::Session::Dalli also accepts a host of options that control how
  # the sessions and session cookies are managed, including the
  # aforementioned `:expire_after` option. Please see the documentation for
  # Rack::Session::Abstract::Persisted for a detailed explanation of these
  # options and their default values.
  #
  # Finally, if your web application is multithreaded, the
  # Rack::Session::Dalli middleware can become a source of contention. You
  # can use a connection pool of Dalli clients by passing in the
  # `:pool_size` and/or `:pool_timeout` options. For example:
  #
  #   use Rack::Session::Dalli,
  #     :memcache_server => "mc.example.com:1234",
  #     :pool_size => 10
  #
  # You must include the `connection_pool` gem in your project if you wish
  # to use pool support. Please see the documentation for ConnectionPool
  # for more information about it and its default options (which would only
  # be applicable if you supplied one of the two options, but not both).
  #
  # @return [Dalli] a new instance of Dalli
  #
  # source://dalli-2.7.11/lib/rack/session/dalli.rb:69
  def initialize(app, options = T.unsafe(nil)); end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:133
  def delete_session(req, sid, options); end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:117
  def destroy_session(env, session_id, options); end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:125
  def find_session(req, sid); end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:95
  def get_session(env, sid); end

  # Returns the value of attribute mutex.
  #
  # source://dalli-2.7.11/lib/rack/session/dalli.rb:8
  def mutex; end

  # Returns the value of attribute pool.
  #
  # source://dalli-2.7.11/lib/rack/session/dalli.rb:8
  def pool; end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:108
  def set_session(env, session_id, new_session, options); end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:129
  def write_session(req, sid, session, options); end

  private

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:140
  def extract_dalli_options(options); end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:160
  def generate_sid_with(dc); end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:181
  def ttl(expire_after); end

  # source://dalli-2.7.11/lib/rack/session/dalli.rb:167
  def with_block(env, default = T.unsafe(nil), &block); end
end

# source://dalli-2.7.11/lib/rack/session/dalli.rb:10
Rack::Session::Dalli::DEFAULT_DALLI_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://rack-2.2.4/lib/rack/session/memcache.rb:8
Rack::Session::Memcache = Rack::Session::Dalli

# source://rack-2.2.4/lib/rack.rb:48
Rack::TRACE = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:34
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack.rb:47
Rack::UNLINK = T.let(T.unsafe(nil), String)

# source://rack-2.2.4/lib/rack/version.rb:16
Rack::VERSION = T.let(T.unsafe(nil), Array)
